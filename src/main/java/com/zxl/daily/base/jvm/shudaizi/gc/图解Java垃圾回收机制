本文链接：https://blog.csdn.net/justloveyou_/article/details/71216049

摘要：
	Java技术体系中所提倡的自动内存管理最终可归结为自动化两个问题：给对象分配内存已经回收分配给对象的内存，而这两个问题针对是内存区域，
就是Java内存模型的堆区，关键对象的内存分配问题，笔者的博文《Java内存模型概述》已经阐述了如何划分可用空间及涉及到线程安全的问题，本文
将结合垃圾回收策略进一步给出内存分配规则。垃圾回收机制的引入可以有效的防止内存泄漏、保证内存的有效使用，也大大解放了程序员的双手，使得
他们在编写程序的时候不在需要考虑内存管理。本文着重介绍判断一个对象是否可以被回收的两种经典算法，并详述四种典型类型的垃圾回收算法的基本
思想及其直接应用--垃圾收集器，最后结合内存回售策略介绍内存分配规则。

一、垃圾回收机制的意义
		在笔者的上一篇博文《JVM内存模型概述》中提到，JVM内存模型一种包括三个部分堆（Java代码可用的Java堆和JVM自身使用的方法区）、
	栈（服务方法的虚拟机栈和Native方法的本地方法栈）和保证程序在多线程下能够连续执行的程序计数器。特别地，我们当时就提到Java堆是进行
	垃圾回收的主要区域，故其也被称为GC堆，而方法区也是一个不严禁的表述，就是永久代。总的来说，堆（包括Java堆和方法区）是垃圾回收的
	主要对象，特别的Java堆。
	
		实际上，Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决两个问题：给对象分配内存以及回收分配给对象的内存，而且这
	两个问题针的是内存区域就是Java内存模型的堆区。关于对象分配的问题，笔者的博文《Java内存模型概述》以及阐述了如何划分可用空间及其涉
	及到的线程安全问题，本文将结合垃圾回收策略进一步给出内存分配规则。另外，我们知道垃圾回收机制是Java语言的一个显著的特点，其有效的
	可以防止内存泄漏、保证内存有效的使用，从而使得Java程序员在编写程序的时候不再需要考虑内存管理问题。Java垃圾回收机制要考虑的问题很
	复杂本文其阐述了三个核心问题，包括：
		* 那些内存需要回收？（对象是否被回收的两种经典算法：引用计数法和可达性分析算法）
		* 什么时候回收？（堆的新生代、老年代、永久代的垃圾回收时机，MinorGC和FullGC）
		* 如何回收？（三种经典垃圾回收算法（标记清除算法、复制算法、标记整理算法）及分代收集算法和七种垃圾收集器）
		
		在探讨垃圾回收之前我们首先要记住一个单词：Stop-theWorld。Stop-the-World意味着JVM由于要执行GC而停止了应用程序的执行，
	并且这种情形会在任意一种算法中发生。当Stop-the-World发生时，除了GC所需的线程以外，所有的线程都处于等待状态直到GC完成任务。
	事实上，GC优化很多时候就是指减少Stop-the-World发生的时间，从而使系统具有高吞吐、低停顿的特点。
	
		Ps：内存泄漏是指内存空间使用完毕之后未回收，在不涉及复杂数据结构额一般情况下，Java的内存泄漏表现为一个内存对象的生命周期超出
	了程序需要它的时间长度。
	
二、如何确定一个对象是否可以被回收？
	1、引用计数算法：判断对象的引用算法
		引用计数算法是通过判断对象的引用数量来决定对象是否被回收。
			引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例
		分配给一个引用变量，该对象的引用计数设置为1。当任何其它变量被赋值为这个对象的引用时，对象的实例引用计数加1（a=b，则b引用的对象
		实例的计数器加1），但当一个对象实例的某个引用超过了生命周期或被设置为一个新的值时，对象实例的引用计数减1。任何引用计数器为0的
		对象实例可以被当做垃圾收集。
		
			引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循
		环引用的问题。如下面的程序和示意图所示，对象ObjA和ObjB之间的引用计数永远不可能为0，那么这两个对象永远不可能被回收。
			MyTest1.java
			上述代码最后面两句objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访问了，但是由于它们互相引用对方，
		导致它们的引用计数器都不为0，那么垃圾收集器就永远不会收集它们。
		
	2、可达性分析算法：判断对象引用链是否可达
		
		可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被收回。
		
			可达性分析算法是从离算数学中的图论引入的，程序把所有引用看作一张图，通过一些列的名为“GC Roots”的对象作为起点，从这个节点
		开始往下搜索，搜索所走过的路径称为引用链（Reference China）。当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从
		GC Roots 到这个对象不可达）时，则证明此对象时不可用的，如下图所示。在Java中，可作为GC Root的对象包括以下几种：
		
			* 虚拟机栈（栈针中的局部变量表）中的引用对象；
			* 方法区中类静态属性引用的对象；
			* 方法区中常量引用对象；
			* 本地方法栈中Native方法引用的对象；
			
三、垃圾收集算法
	1、标记清除算法
		标记-清除算法分为标记和清除两个阶段。该算法首先从根集合开始进行扫描，对存活的对象标记，标记完毕后，再扫描整个空间中未被标记的对象
	进行回收，如图所示：
		此处省略图。。。
		
		标记清除算法主要不足有两个：
		* 效率问题：标记和清除两个过程效率都不高；
		* 空间问题：标记-清除算法不需要对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多
				可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存空间而不得不提前触发另一次垃圾收集动作。
				
	2、复制算法
		复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再
	把已使用的内存空间一次清掉。这种算法用于存活率低的场景，比如新生代。这样使得每次都是对整个半区进行回收，内存分配时也就不用考虑内存碎片等
	情况，只要移动堆定指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示：
		此处省略图。。。
		
		事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以虚拟机
	复制的对象太少，效率还不错。正如在博文《JVM内存模型概述》中介绍的那样，实践中会将新生代的内存分为一个较大的Eden空间和两块较小的Survivor
	空间（如下图所示），每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次地复制到另一个Survivor空间上，
	最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个
	新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
		此处省略图。。。
		
	3、标记整理算法
		复制收集算法在对象存活率较高时就要进行较多的复杂操作，效率将会变低。更关键是，如果不想浪费50%的空间，就需要在额外的空间进行分配担保，
	以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤
	不是直接对可回收对象进行清理，而是让所有的存活的对象向一端移动，然后清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾收集算法适合于对象
	存活率高的场景（老年代），其作用原理如下图所示。
		此处省略图。。。
		
		标记整理算法与标记清除算法最显著的区别：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有存活的对象
	移到一端，并对不存货的对象进行处理，因此其不会产生内存碎片。标记整理算法的示意图如下：
		此处省略图。。。
		
	4、分代收集算法
		对于一个大型系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必效率低下。分集算法基于
	这样一个事实：不同的对象的生命周期（存活情况）是不一样，而不同的生命周期对象位于堆中不同的区域，因此对堆内存不同的区域采用不同的策略进行回收
	可提高JVM的执行效率。当代商用虚拟机使用的是分代收集算法：新生代对象存活率低，就采用复制算法；老年代对象存活率高，就采用标记清除算法或着标记
	整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：
		此处省略图。。。
		
		1）新生代（YoungGeneration）
			新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生产的对象首先都放到新生代的。新生代内存按照8:1:1 的
		比例分为一个eden区和两个survivor（survivor0，survivor1）区，大部分对象在Eden区中生成的。在进行垃圾回收时，现将Eden区存活
		对象复制到survivor0区，然后清空eden区，当Eden区也满时，则将Eden区和survivor0区存活的对象一块复制到survivor1区，然后清空
		Eden区和survivor0区，此时survivor0是空的，然后交换survivor0和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1
		区），即保持survivor0区为空，如此反复。特别地，当survivor1区也不足存放Eden区和survivor0区的存活对象时，就将存活对象直接存放
		老年代。如果老年代也满了就会触发一次FullGC，也就是新生代和老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率
		比较高，不一定等Eden区满了才触发。
		
		2）老年代
			老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中进行了N次垃圾回收后仍然存活的对象就会被放到老年代。此外
		老年代的内存也比新生代大很多（大概比例1:2），当老年代满时会触发MajorGC（FullGC），老年代对象存活比较长，因此FullGC发生的频率
		比较低。
		
		3）永久代
			永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如：
		使用反射、动态代理、CGLib等bytecode框架时，在这个时候需要设置一个比较大的永久代空间来存放这些在运行过程中新增的类。
		
	5、小结
		由于对象进行分代处理，因此垃圾回收区域、时间也不一样，垃圾回收有两种类型，MinorGC和FullGC。
		MinorGC：对新生代进行回收，不会影响老年代。因为新生代对象大多死亡比较频繁，所以Minor GC非常频繁，一般在这里使用速度快、效率高的
				算法，使垃圾回收能尽快完成。
		Full GC：也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC要对整个堆进行回收，所以比Minor GC要慢，因此应该尽量
				减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显示调用时等。
				
四、垃圾收集器
		如果说垃圾收集器算法是内存回收的方法论，那么垃圾收集器就是内存回收的实现。下图展示了7中作用于不同的收集器，其中用于回收新生代的收集器
	包括：Serial、ParNew、Parallel Scavenge，回收老年代的收集器包括：Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的
	G1收集器。不同收集器之间的连线表示它们可以搭配。
		此处省略图。。。
		
		* Serial收集器（复制算法）：新生代单线程收集器，标记和清除都是单线程，优点是简单高效。
		
		* Serial Old收集器（标记-整理算法）：老年代单线程收集器，Serial收集器的老年代版本。
		
		* ParNew收集器（复制算法）:新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。
		
		* Parallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU。吞吐量=用户线程时间/(用户线程时间+GC线程时间)，
								高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景。
		
		* Parallel Old收集器（标记-整理算法）：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本。
		
		* CMS（Concurrent Mark Sweep）收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高
							并发、低停顿的特点，追求最短GC回收停顿时间。
							
		* G1(Garbage First)收集器(标记-整理算法):Java堆并行收集器，G1收集器是JDk1.7提供的一个新的收集器，G1收集器基于
						“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前收集器的一个重要特点是：G1
						回收的范围是整个Java堆（新生代、老年代），而前六种收集器回收的范围仅限于新生代或者老年代。
						
五、内存分配与回收策略
		Java技术体系中所提倡的自动回收内存管理最终可归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。一般而言
	对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存（TLAB），将按线程优先分配在TLAB上，少数情况下也可能直接分配到老年代，
	总的来说，内存分配规则并不是一成不变的，其细节取决于当前使用的是那一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。
	
		1）对象优先在Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发生一次MinorGC。现在商业虚拟机一般都采用复制算法来
	回收新生代，将内存分为一块较大的Eden区和两块较小相等的Survivor空间，每次使用Eden和其中一个块survivor。当进行垃圾回收时，
	将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后处理掉Eden区和刚才的Survivor空间。当Survivor空间
	不够用时，需要依赖老年代进行分配担保。
	
		2）大对象直接进入老年代。所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。
		
		3）长期存活的对象进入老年代。当对象在新生代进行过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。
		
		4）动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold
	才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接
	进入老年代，无须等到	MaxTenURingThreshold中要求的年龄。
	
		需要注意的是，Java的垃圾回收机制是Java虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存
	空间。也就是说，垃圾收集器回收的是无任何引用的对象占据的内存空间而不是对象本身。
	
六、Java中的内存泄漏问题
	虽然Java拥有垃圾回收机制，但同样会出现内存泄漏问题，比如下面提到的几种情况：
		（1）诸如HashMap、Vector等集合类的静态使用最容易出现内存泄漏，因为这些静态变量的生命周期和应用程序一直，所有的对象Object
	也不会被释放，因为他们也将一直被Vector等应用着。
		例如MyTest2.java
		
		在这个例子中，虚拟机栈中保存着Vector对象的因为v和Object对象的引用o。在for循环中我们不断的生成新的对象，然后将其添加到
	Vector对象中，之后将o引用置空，但当发生垃圾收集时，我们创建的Objec对象也不能被回收，因为垃圾回收在跟踪代码栈中的引用时会发现
	v 引用，而继续往下跟踪会现在 v 引用指向的内存空间中又指向Object 对象应用，也就是说，尽管o引用已经被置空，但Object对象仍存在
	其它的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后，Object对象对程序已经没有任何作用，那么我们就认为此Java
	程序就发生了内存泄漏。
	
		（2）各类资源连接包括数据库连接、网络连接、IO连接等没有显示调用close关闭，不被GC回收导致内存泄漏。
		
		（3）监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄漏。
		
七、知识点补充
	1、引用
		1).引用概述
			无论是通过引用计数算法判断对象的引用变量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”
		有关。在JDK1.2之前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块
		内存代表着一个引用。这种定义很纯粹，但太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之
		无味，弃之可惜”的对象显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存在进行垃圾收集
		收还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。
		
			为此，在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚拟引用四种，这四种引用强度依次
		逐渐减弱。
		
		2）引用的种类及其定义
			强引用就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()”这类引用。只要强引用还存在，垃圾收集器
		就永远不会收集掉引用的对象。
			
			软引用用来描述一些还在用，但并非必须的对象。对于软引用关联着的对象，在内存将要发生内存溢出异常之前，将会把这些对象列进
		回收范围之中并进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来
		实现软引用。
		
			弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当
		垃圾收集时，无论当前内存是否足够，都会回收掉只被软引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
		
			虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取的一个对象
		的实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了
		PhantomReference类来实现虚引用。
		
	2、方法区的回收
		方法区的内存回收目的主要是针对 常量池的回收和对类型的卸载。回收废弃常量与回收Java堆中的对象非常类似。以常量池中的字面量为例
	例如一个字符串 “abc” 已经进入常量池中，但当前系统没有任何一个String对象是 “abc” 的，换句话说是没有任何String对象引用常量池
	中的 “abc” 常量，也没有其他地方引用这个字面量，如果在这个时候发生内存回收，而且必要的话，这个 “abc” 常量就会被系统 “请” 出常量
	池。常量池中其它的类（接口），方法、字段的符号引用也与此类似。
	
		判断一个常量是否是 “废弃常量” 比较简单，而要判断一个类是否是 “无用的类” 的条件则相对苛刻许多。类需要同时满足下面3个条件才能
	算是 “无用的类” ：
		1）该类的所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
		2）加载该类的ClassLoader已经被回收；
		3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法。
		
		虚拟机可以对满足上述3个条件的无用类进行回收（卸载），这里说的是仅仅是 “可以” ，而不是和对象一样，不使用了就必然会回收。特别
	地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机
	具备卸载的功能，以保证永久代不会被溢出。
		
		
		
		
		
		