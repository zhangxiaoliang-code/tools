https://blog.csdn.net/justloveyou_/article/details/72466105
一、类加载机制概述

二、类加载时机
	1.类加载时机
  		什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现
  	来自由把握。
  	
	2.类初始化时机
  		那么，什么情况下虚拟机需要初始化一个类呢？这在虚拟机规范中有严格规定的，虚拟机规范指的是有且只有五种情
  	况必须立即对类进行初始化（而这一过程必然是发生在加载、验证、准备之后）。
  	
  		1）遇见new、getstatic、putstatic或invokestatic这四条字节码指令（注意，newarray指令触发的
  	只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]指挥直接触发String[]类的初
  	始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化）时，如果类没有进行初
  	始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：
  		* 使用new关键字实例化对象的时候；
  		* 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
  		* 调用一个类的静态方法的时候。
  		2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其
  	初始化。
  		3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。
  		4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个类。
  		5）当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果
  	REF_getstatic,REF_putstatic,REF_invokestatic的方法句柄，并且这个方法句柄所对应的类没有进行
  	实例化，则需要先触发其初始化。
  		
  	注意，对于这五种会触发类初始化的场景，虚拟机规范中使用一个很强烈的限定语：“有且只有”，这五种场景中的行为
  	成为对一个类进行“主动使用”。除此之外，所有引用类的方式，都不会触发初始化，称为“被动引用”。
  	
  	特别需要指出的是，类的实例化和类的初始化是两个完全不同的概念：
  	类的实例化：指创建一个类的实例（对象）过程。
  	类的初始化：类中各个成员（被static修饰的成员变量）赋初始值的过程，是类生命周期的一个阶段。
  	
  	3.被动引用的集中经典场景
  		1）通过子类引用父类的静态字段，不会导致子类初始化。
  		例：MyTest.java
  		2）通过数组定义来引用类，不会触发此类的初始化。
  		例：MyTest.java
  		3）常量在编译阶段会存入调用类的常量池中，本质上并没有引用到定义常量的类，因此不会触发定义常量的类的
  	初始化。
  		例：MyTest2.java
  		
三、类加载过程
	类的生命周期：加载-验证-准备-解析-初始化-使用-卸载
	1.加载（Loading）
		在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法）虚拟机需要完成以下三件事：
		（1）通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从
	其它渠道，譬如：网络、动态生成、数据库等）；
		（2）将这个字节流所代表的静态存储结构转化为方法区的运行时结构数据；
		（3）在内存中（对于HotSpot虚拟机而言就是方法区）生成一个代表这个类的java.lang.Class对象，
	作为方法区这个类的各种数据的访问入口；
		
		加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段
	尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中的动作，仍然属于连接阶段的内容，这两个阶段的开始
	时间仍然保持这固定的先后顺序。
		特别地，第一件事情（通过一个类的全限定名类获取定义此类的二进制字节流）是由类加载器完成的，具体涉及
	JVM预定义的类加载器、双亲派模型等内容，详情请参见我的转载博文《深入理解Java类加载器（一）：java类
	加载原理解析》中的说明。
	
	2.验证（Verification）
		验证是连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，
	并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
		*文件格式验证：验证字节流是否符合Class文件格式的规范（例如：是否以魔术0xCAFEBABE开头、主次版
		  本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型）
		*元数据验证：对字节码描述的信息进行语义分析，以保证描述的信息符合Java语言规范的要求（例如：这个类
		  是否有父类，除了java.lang.Object之外）；
		*字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
		*符号引用验证：确保解析动作能正确执行。
			验证阶段是非常重要的，但不是必须的，它对程序区没有影响。如果所引用的类经过反复验证，那么可以
		  考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
		  
	3.准备（Preparation）
		准备阶段是正式为类变量（static成员变量）分配内存并设置类变量初始值（零值）的阶段，这些变量所使用
	的内存都将在方法区中进行分配。这时候进行类分配的仅包含类变量，而不包含实例变量，实例变量将会在对象实例化
	时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个变量的定义为：
	public static int value = 123；
	那么，变量value在准备阶段过后的值为0而不是123。因为这时候尚未开始执行任何java方法，而把value赋值为
	123的putstatic的指令是程序被编译后，存放于类构造器方法<clinit>()之中，所以把value赋值为123的动
	作将在初始化阶段才会执行。至于“特殊情况”是指：当类字段的字段属性是ConstantValue时，会在准备阶段初始
	化为指定值，所以标注为final之后，value的值在准备阶段初始化为123而非0。
	public static final value = 123；
	
	4.解析（Resolution）
		解析阶段是虚拟机将常量池内的符号引用替换为直接引用过程。解析动作主要针对类或接口、字段、类方法、接口
	方法、方法类型、方法句柄和调用点限制符7符号引用进行。
	
	5.初始化（initialzation）
		类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类
	加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，菜真正开始执行类中定义的java程序代码（字
	节码）。
	
		在准备阶段，变量已经赋值过一次系统要求的初始值（零值）；而在初始化阶段，则根据程序员通过程序指定的主
	观计划去初始化类变量和其他资源，或者更直接的说：初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>
	()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的
	顺序是由语句在源文件中出现的顺序所确定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变
	量，在前面的静态语句块中可以赋值，但是不能访问。
		例：MyTest3.java
		
		类构造器<clinit>()与实例构造器<init>()不同，它不需要程序员进行显示调用，虚拟机会保证在子类类构造
	器<clinit>()执行之前，父类的构造器<clinit>()执行完毕。由于父类的构造器<clinit>()先执行，也就意味着
	父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。特别地，类构造器
	<clinit>()对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有类变量的赋值操作，那么编译器
	可以不为这个类生成类构造器<clinit>()。
	
		虚拟机会保证一个类的类构造器在多线程环境中被正确加锁、同步，如果多个线程同时去初始化一个类，那么只会有
	一个线程执行这个类的类构造器<clinit>(),其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。特
	别需要注意的是，在这种情形下，其他线程虽然会阻塞，但如果执行<clinit>()方法的那条线程退出后，其他线程在唤醒
	之后不会再次进入/执行<clinit>()方法，因为在同一个类加载器下，一个类型只会被初始化一次。如果在一个类<clinit>
	()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐蔽的。
		例：MyTest4.java
	
四、典型案例分析
	我们知道，再Java中，创建一个对象常常要经历如下几个过程：父类的类构造器<clinit>()->子类的类构造器
<clinit>()->父类的成员变量和实例代码块->父类的构造函数->子类的成员变量和实例代码块->子类的构造函数。至于
为什么是这样一个过程，笔者笔者在本文的弟妹篇《深入理解Java对象的创建过程：类的初始化和实例化》很好的解释了这
个问题。
	例：MyTest5.java
	结果：实例初始化不一定要在类初始化结束之后才开始初始化。
		实际上是把实例初始化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置。

	
	
	
	
	
	
	
	