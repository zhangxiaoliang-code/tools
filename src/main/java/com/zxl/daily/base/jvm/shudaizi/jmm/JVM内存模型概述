JVM内存模型
https://blog.csdn.net/justloveyou_/article/details/71189093

摘要：
		我们都知道，Java程序在执行前首先都会编译成字节码文件，然后再有Java虚拟机执行这些字节码文件从而使得这些Java程序得以执行。
	事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干的
	不同数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间，并且它们可以分为两种类型：线程共享的方法区和堆，线程私有的虚拟机
	栈、程序计数器和本地方法栈。在此基础上，我们探讨了在虚拟机中对象的创建和对象的访问定位等问题，并分析了Java虚拟机规范中异常产生
	的情况。
	
一、Java虚拟机内存模型
		Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干的不同数据区域，这些数据区域可以分为两个部分，一部分是线程
	共享的，一部分是线程私有的。其中，线程共享的数据区域包含方法区和堆，线程私有的数据区域包含虚拟机栈、本地方法栈和程序计数器。
	如图所示：
		此处省略JMM模型图。。。
		
	1、线程私有的数据区域
		线程私有的数据区域包括：虚拟机栈、本地方法栈和程序计数器。它们的内涵如下：
		
		1）、程序计数器
			我们知道，线程是CPU调度的基本单位。在多线程情况下，线程数量超过CPU数量或者CPU内核数量时，线程之间就要根据时间片轮训
		抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程的指令。因此，为了线程切换后能够正确的恢复到
		正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。
			因此，程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指令器。如果线程正在执行的是一
		个Java方法，计数器记录的是正在执行的字节码指令的地址；如果在正执行的是Native方法，则计数器的值为空。
		
		程序计数器是唯一一个没有规定任何OutOfMemoryError的区域。
		
		2）、虚拟机栈
			虚拟机栈描述的是Java方法执行的内存模型，是线程私有的。每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、
		操作数栈、动态链接、方法出口等信息，而且每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，
		局部变量表存放一些基本数据类型的变量（int、short、double、byte、long、boolean、float、char）和对象句柄，
		它们可以是方法的参数，也可以是方法的局部变量。
			
			虚拟机栈有两种异常情况：StackOverflowError和OutOfMemoryError。我们知道，一个线程拥有一个自己的栈，这个栈的
		大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小），若栈帧请求的栈的深度
		大于虚拟机允许的深度，则抛出StackOverflowError异常。此外，栈的大小可以是固定的，也可以是动态扩展的，若虚拟机可以动态
		扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存（比如没有足够的内存为一个新创建的线程分配栈空间时），则抛出
		OutOfMemoryError异常。下面为栈帧结构图：
			此处省略栈帧结构图。。。
			
		3）、本地方法栈
			本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机栈执行的方法服务，而本地方法栈为虚拟机
		执行Native方法服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。
		
	2、线程共享的数据区域
		线程共享的数据区域 具体包括Java堆和方法区两个区域，它们的内涵分别如下：
		
		1）、Java堆
			Java堆的唯一目的就是存放对象的实例，几乎所有的对象实例（和数组）都在这里分配内存。Java堆是线程共享的，类的对象从中
		分配空间，这些对象通过new、newarray、anewarray和multiannewarray等指令建立，它们不需要程序代码来显示的释放。
		
			由于Java堆唯一目的就是用来存放对象的实例，因此，其它是垃圾收集器管理的主要区域，故也称为GC堆。从内存回收的角度看，
		由于现在的垃圾收集器基本采用分代手机算法，所以为了方便垃圾回收Java堆还可以分为新生代和老年代。新生代用于刚创建的对象以及
		年轻的对象，如果对象一直没有回收，生存的足够长，对象就会被移入到老年代。新生代又可进一步细分为eden、survivorSpace0
		和survivorSpace1。刚创建的对象都放到eden、s0和s1都至少经过一次GC并幸存。如果幸存对象经过一段时间仍存在，则进入
		老年代。更多关于Java堆和分代收集算法，请移步我的博文《Java垃圾回收机制概述》。下面给了Java堆的结构图：
			此处省略Java堆的结构图。。。
			
			注意，Java堆可以处理物理上不连续的内存空间中，只要逻辑上是连续的即可。而且，Java堆在实现时，既可以是固定大小的，也
		可以是可扩展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx（最大堆容量）和-Xms（最小堆容量）控制）。如果在堆中没有内存
		完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常。
		
		（1）、TLAB（Thread Local Allocation Buffer，线程私有分配缓冲区）
			Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB，其大小由JVM根据运行情况
		计算而得。在TLAB上分配对象时不需要加锁（相对于CAS配上重试方式），因此，JVM在给线程的对象分配内存时会尽量的在TLAB上分配，
		在这种情况下JVM中分配对象内存的性能和C基本上是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。
		
			在下文件我们提到的，虚拟机为新生对象分配内存时，需要考虑修改指针（该指针用于划分内存使用空间和空闲空间）时的线程安全
		问题，因为存在可能出现正在给对象A分配内存，指针还没修改，对象B又同时使用原来的指针分配内存的情况。TLAB的存在就是为了解决
		这个问题：每个线程在Java堆中预先分配一小块TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。
		
		2）、方法区
			方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器
		编译后的代码等数据。方法区通常和永久区（Perm）关联在一起，但永久代和方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，
		这样就可以用永久区GC来管理方法区了，省去专门内存管理的工作。根据Java虚拟机规范的规定，当方法区无法满足内存分配的需求时，
		将会抛出OutOfMemoryError异常。
		
		（1）、运行时常量池
			运行时常量池（Runtime Constant Pool）时方法区的一部分，用于存放编译期生成的各种字面量和符号引用。其实，字面量
		比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类
		常量：类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符。应为运行时常量池（Runtime Contant Pool）是方法区
		的一部分，那么当常量池无法在申请到内存时也会抛出OutOfMemoryError异常。
			运行时常量池相对于Class文件常量池的一个重要特性是具备动态性。Java语言并不要求常量一定只有编译器才能产生，运行期也
		可能将新的常量池放入pool中，比如说string的手动入pool method intern()。
		
		3)、Java堆与方法区的区别
			Java堆是Java代码可及的内存，是留给开发人员使用的；而非堆是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的
		内存(如JIT编码后的代码缓存)、每个类结构（如运行时常量池、字段和方法数据）以及方法和构造方法的代码都在非堆内存中。
		
		4)、方法区的回收
			方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。回收废弃常量与回收Java堆中的对象非常类似。以常量池中的字
		面量为例，假如一个字符串 “abc” 已经进入常量池中，但是当前系统没有任何一个String对象是叫做 “abc” 的，换句话说是没有任
		何String对象引用常量池中的 “abc” 常量，也没有其它四方引用这个字面量，如果在这个时候发生内存回收，而且必要的话，这个
		“abc”常量就会被系统“请”出常量池，常量池中的其它类（接口）、方法、字段的符号引用也与此类似。
		
			判断一个常量是否是 "废弃常量" 比较简单，而要判断一个类是否是 “无用的类” 的条件则相对苛刻许多，类需要满足下面3个条件
		才能算是 “无用的类” ：
			* 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例；
			* 加载该类的ClassLoader已经被回收；
			* 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
			
			虚拟机可以对满足上述3个条件的无用类进行回收（卸载），这里说的仅仅是“可以”，而不是和对象一样，不适用了就必然会回收。
		特别的，在大量使用反射、动态代理、CGLib等bytecode框架场景，已经动态生成JSP和OSGI这类频繁自定义ClassLoader的场景
		都需要虚拟机具备卸载的功能，以保证永久代不会被溢出。
		
二、Java对象在虚拟机的创建和访问定位
		Java是一门面向对象的编程语言，在Java程序的运行过程中无时无刻都有对象被创建和使用，在此，我们以HotSpot虚拟机即常用的
	内存区域Java堆为例来探讨在虚拟机中对象的创建和对象的访问的问题。
	
	1、对象在虚拟机中的创建过程
		（1）检查虚拟机是否加载了所要new的类，若没加载首先要执行加载类的过程。虚拟机遇到new指令时，首先去检查这个指令的参数是否能
	在常量池中定位到一个类的符号引用，并检查这个引用代表的类是否已经被加载、解析和初始化过。
		（2）在类加载检查通过后，对象在内存所需的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存，一般来说，根据Java堆
	中内存是否绝对完整，内存的分配有两种方式：
		* 指针碰撞：如果Java堆中内存绝对规整，所有用过的内存放在一边，没有使用过的内存放在另一边，中间一个指针作为分界点的指示器，
			那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相同的距离。
		* 空间列表：如果Java堆中内存并不规整，那么虚拟机就需要维护一个列表，记录那些内存是可用的，以便在分配的过程中找到足够大的内存
			划分给对象实例，并更新列表上的记录。
			
			除了如何划分可用空间之外，还要考虑修改指针（该指针用于划分内存使用空间和空闲空间）时的线程安全问题，因为可能出现正在给A对象
		分配内存，指针还没修改，对象B同时又使用原来的指针分配内存的情况。解决这个问题有2种方案：
			* 对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性。
			* 把内存分配的动作按照线程划分的不同的空间中，每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个
				线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。
				
		（3）内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值。如果使用TLAB，也可以提前到TLAB分配时进行。这一步操作保证了对象
	的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
		
		（4）在上面的工作完成之后，从虚拟机的角度看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行
	<init>方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。
	
	2、对象在虚拟机中的访问定位
		创建对象是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。在虚拟机规范中，reference类型中规定了
	一个指向对象的引用，并没有定义这个引用使用什么方式去定位、访问堆中的对象的具体位置。目前的主流的访问方式有使用句柄访问和直接指针访问。
	
		* 句柄访问：Java堆中会划分出一块内存作为句柄池，栈中的reference指向对象的句柄池地址，句柄池中包含了对象的实例数据和类型数据
			各自的具体地址信息，如图：此处省略图。。。
		* 直接指针访问：reference存储的就是对象地址。
		
		总的来说，这两种对象访问定位各有千秋。使用句柄访问的最大好处是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对
	象时非常普遍的行为）时只会改变句柄中的实例数据指针，reference本身不需要修改；而使用直接指针访问的最大好处就是速度快，节省了一次指针
	定位的时间开销。
	
三、内存异常产生情况分析
	1、Java堆溢出（OOM）
		Java堆用于存储对象的实例，只要不断创建对象，并且保证GC roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量
	到达最大堆的容量限制后就是产生内存溢出异常。如下所示：
		Mytest2.java
		
		要解决这种异常，一般先通过内存映像分析工具对堆转储快照分析，确定内存的对象是否是必要的，即判断大势内存泄漏还是内存溢出。如果是
	内存泄漏，可以进一步通过工具查看泄漏对象到GC roots的引用链，比较准确地定位出泄漏代码的位置。如果是内存溢出，可以调大虚拟机堆的参数，
	或者从代码上检查是否存在某些对象生命周期过长的情况。
	
	2、虚拟机栈和本地方法栈溢出（SOF和OOM）
		1）.SOF
			如果线程请求的栈的深度大于虚拟机栈允许的最大深度，将抛出 “StackOverflowError”异常。我们知道，每当Java程序启动一个线程
		时，Java虚拟机为它分配一个栈，并且Java虚拟机栈以栈帧为单位保持线程运行状态。每当线程调用一个方法时，JVM就压入一个新的栈帧到这个
		线程栈中，只要这个方法还没有返回，这个栈帧就存在。那么可以想象，如果方法嵌套嗲用的层数太多，比如递归调用，随着Java虚拟机栈的栈帧
		的不断增加，最终很有可能导致这个线程的栈中的所有栈帧大小的总和大于-Xss设置的值，从而产生StackOverflowError溢出异常。
			例如：MyTest3.java
			
			例子中的SOF异常就是递归引起的，具体而言就是method()方法中的递归没有终止条件，从而使得该方法不断的递归调用，不断的创建栈帧
		导致的。
		
		2）.OOM
			如果虚拟机在拓展栈时，无法申请足够的内存空间，则抛出OutOfMemoryError异常。在虚拟机栈和本地方法栈发生OOM异常场景如下：
		当Java程序启动一个新线程时，若没有足够的空间为线程分配Java栈（一个线程Java栈的大小由-Xss设置决定），JVM将抛出
		OutOfMemoryError异常。
		
	3、方法区和运行时常量溢出（OOM）
		运行时常量池溢出的情况：String.intern()是一个native方法，在JDK1.6及之前的版本中，它的作用：如果字符串常量池中已经包含一个
	等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则将此String对象包含的字符串添加到常量池中，并且返回此String
	对象的引用。由于常量池分配在永久代中，如果不断的使用intern方法手动入池字符串，则会抛出StackOverflowError异常。但在JDK1.7及其
	以后的版本中，对intern方法的实现作了进一步的改进，其不会在复制实例到常量池中，而仅仅是在常量池中记录首次出现的实例引用。
		例如：MyTest4.java
		
		为什么第一个返回true，而第二个返回false呢？因为在JDK1.7中，intern（）方法的实现不会再复制实例，只会在常量池中记录首次出现
	的实例引用，因此str1.intern()和str1指向的是同一个字符串，所以返回true。同一个引用对于“java”这个字符串，由于在执行
	StringBuilder.toString()之前已经出现过，所以字符串常量池中在new StringBuilder("java").toString()之前已经有它的引用
	，不符合首次出现的原则，因此返回false。
	
		由上面代码可知，字符串”java”早就出现了，因此不符合首次出现的原则，返回false。同理，“计算机软件”这个字符串在
	new StringBuilder(“计算机”).append(“软件”).toString()之前从未出现过，因此符合首次出现的原则，返回true。
	
		要想更彻底地了解本实例，建议一步我的博文《Java String综述（上篇）》和《Java String综述（下篇）》进行进一步了解。
	