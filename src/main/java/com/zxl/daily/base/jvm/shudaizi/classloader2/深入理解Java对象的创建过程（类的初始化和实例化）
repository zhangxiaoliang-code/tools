https://blog.csdn.net/justloveyou_/article/details/72466416
一、java对象创建时机
	我们知道，一个对象在可以被使用之前必须要被正确的实例化。在java代码中，有很多行为可以引起对象的创建，最为直观
的一种就是使用new关键字来调用一个类的构造函数显示的创建对象，这种方式在Java规范中被称为：“由执行类实例创建表达式
而引起的对象创建”。除此之外，我们还可以使用反射机制（Class类的newInstance方法、使用Constructor类的
newInstence方法）、使用Clone方法、使用反序列化等方法创建对象。
	1).使用new关键字创建对象
		这是我们最常见也是最简单的常见对象的方式，通过这种方式我们可以调用任意的构造函数（无参的和有参的）去创建
	对象。
		例：Student student = new Student();
		
	2).使用Class类的newInstence方法（反射机制）
		我们可以通过java的反射机制使用Class类的newInstance方法来创建对象，事实上，这个newInstance方法调
	用的无参的构造器创建对象。
		例：Student student2 = Class.forName("Student类全限定名").newInstance();
			或者: Student stu = Student.class.newInstance();
			
	3).使用Constructor类的newInstance方法（反射机制）
		java.lang.relect.Constructor类中也有一个newInstance方法可以创建对象，该方法和Class类中的
	newInstance方法很像，但是相比之下，Constructor类的newInstance方法更强大些，我们可以通过这个
	newInstance方法调用有参数的和私有的构造函数。
		例：MyTest1.java
		结论：使用nweInstance方法的这两种方式创建对象所采用的是反射机制，事实上Class的newInstance方法内部
	调用的也是Constructor的newInstance方法。
	
	4).使用Clone方法创建对象
		无论何时我们调用一个对象的clone方法，JVM都会帮助我们创建一个新的、一样的对象，特别需要说明的是，用clone
	方法创建对象的过程中并不会调用任何的构造函数。关于如何使用clone方法以及浅克隆/深克隆机制，笔者已经在博文《java
	String 综述（下篇）》做了详细说明。简单而言，要想使用clone方法，我们就必须实现Cloneable接口并实现其定义的
	clone方法，这也是原型模型的应用。
		例：MyTest2.java
	
	5).使用（反）序列化机制创建对象
		当我们反序列化一个一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数，为了
	反序列化一个对象，我们需要让我们的类实现Serializable接口，
		例：MyTest3.java
		
	6).完整实例
		例：MyTest4.java
		结论：从Java虚拟机的层面看，除了使用new关键字创建对象的方式外，其他方式全都是通过转变为invokevirtual
	指令直接创建对象。
	
二、Java对象的创建过程
	当一个对象被创建时，虚拟机就会为其分配内存来存放对象自己的实例变量及其从父类继承过程的变量（即使这些从超类继承过
来的实例变量有可能被隐藏也会被分配空间）。“在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值（零值）”。
在内存分配完之后，Java虚拟机就会被新创建的对象按照程序员的意志进行初始化。在Java对象初始化过程中，主要涉及到三种执行
对象初始化的结构，分别是“实例变量初始化、实例代码块初始化以及构造函数初始化”。

	1、实例变量初始化与实例代码块初始化
		我们在定义（声明）实例变量的同时，还可以对实例变量可以赋值或者使用实例代码块对其进行赋值。如果我们以这两种方
	式为实例变量进行初始化，那么它们将在构造函数执行之前完成这些初始化操作。“实际上，如果我们对实例变量直接赋值或者使
	用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后
	（还记得吗？Java要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数的本身的代码之前。”
		例：MyTest5.java
		上面的例子正好验证了上面的结论。特别需要注意的是，Java是按照编程顺序来执行实例变量初始化器和实例初始化器中
	的代码的，并且不允许顺序靠前的实例化代码块初始化在其后面定义的实例变量，
		例：MyTest6.java
		上面的这些代码都是无法通过编译的，编译器会抱怨说我们使用了一个未经定义的变量。之所以要这么做是为了保证一个变
	量在被使用之前已经被正确地初始化。但是我们仍然有办法绕过这种检查。
		例：MyTest7.java
		如果我们执行上面这段代码，那么会发现打印的结果是0.因此我们可以确信，变量j被赋予了i的默认值0，这一动作发生在
	实例变量i初始化之前。
	
	2.构造函数初始化
		我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数之前，那么我们下面着重看看构造函数初始
	化过程。众所周知，每个Java中的对象都至少会有一个构造函数，如果我们没有显示构造定义函数，那么它将会有一个默认无参
	的构造函数。在编译生成字节码中，这些构造函数会被命名成<init>()方法，参数列表与Java语言书写的构造函数的参数列表
	相同。
		我们知道，“Java要求在实例化类之前，必须先实例化超类，以保证所创建实例的完整性”。事实上，这一点是在构造函数
	保证的：Java强制要求Object对象（Object是Java的顶层对象，没有超类）之外的所有对象构造函数的第一条语句必须是
	超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们即没有调用其他构造函数，也没有显示调用超类的构造函数
	那么编译器会为我们自动生成一个对超类构造函数的调用。
		例：MyTest8.java
		对于上面的代码中定义的类，我们观察编译之后的字节码，我们会发现编译器为我们生成一个构造函数，如下，
	aload_0  
	invokespecial   #8; //Method java/lang/Object."<init>":()V  
	return
		上面代码第二行就是调用Object类的默认构造函数的指令。也就是说，如果我们显示调用超类的构造函数，那么该调用必须
	放在构造函数所有代码的最前面，也就是必须是构造函数的第一条指令，正因为如此，Java才可以使的一个对象在初始化之前其
	所有的超类都被初始化完成，并保证创建一个完整的对象出来。
		特别地，如果我们在一个构造函数中调用另一个构造函数，
		例：	MyTest9.java
		对于这种情况，Java只允许在ConstructorExample(1)内调用超类的构造函数，也就是说，下面两种情形的代码编译
	是无法通过的：
		例：MyTest10.java
		Java通过对构造函数做出这种限制以保证一个类的实例能够在被使用之前正确的初始化。
	
	3.小结
		总而言之，实例化一个类的对象过程是一个典型的递归过程，如图所示。进一步地说，在实例化一个类的对象时，具体过程是
	这样的：
		在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，
	依次递归直到递归到Object类，再依次对以下各类进行实例化，直到完成对目标类的实例化。具体而言，在实例化每个类时，
	都遵循如下顺序：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化，也就是说，编译器会将实例变量初始化
	和实例代码块初始化相关代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码
	之前。
		关于递归思想与内涵的介绍，请参见我的博文《算法设计方法：递归的内涵与经典应用》。
		https://blog.csdn.net/justloveyou_/article/details/71787149
		
	4.实例变量初始化、实例代码块初始化以及构造函数初始化综合实例
		笔者再《JVM类加载概述：加载时机与加载过程》一文中详细阐述了类初始化时机和初始化过程，并在文章最后留一个悬念
	这里来接看这个悬念，
		例：MyTest11.java
		在通过使用Bar类的构造方法new一个Bar实例时，首先会调用Foo的构造函数，因此（1）出输出是2，这从Foo类构造函数
	的等价变换中可以直接看出。（2）处输出是0，为什么呢？因为在执行Foo的构造函数过程中，由于Bar重载了Foo中的getValue
	方法，所以根据Java的多态性可以知道，其调用的getvalue方法是Bar重载的那个getvalue方法。但由于这时Bar的构造函数
	还没有被执行，因此此时j的值还是默认值0，因此（2）出输出是0.最后，在执行（3）出的代码时，由于Bar对象已经创建完成，
	所以此时再访问j的值时，就得到了其初始化的值2，这一点可以从Bar类构造函数的等价变换中直接看出。
	
三.类的初始化时机与过程
		关于类的初始化时机，笔者在博文《JVM类加载机制概述：加载时机与加载过程》已经介绍的很清楚了，此处不再嫯述。简单
	的说，在类加载过程中，准备阶段时正式为类变量（static 成员变量）分配内存并设置变量初始值（零值）的阶段，而初始化阶
	段是真正开始执行类定义的java程序代码（字节码）并按程序员的意图去初始化类变量的过程。更直接的说，初始化阶段就是执行
	类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块static{}
	中的语句合并产生的，其中编译器手机的顺序是由语句在源文件中出现的顺序所决定的。
		
		类构造器<clinit>()与实例构造器<>()不同，它不需要程序员进行显示调用，虚拟机会保证在子类类构造器<clinit>()
	执行之前，父类的类构造器<clinit>()执行完毕。由于父类构造器<clinit>()先执行，也就意味着父类中定义的静态代码块/
	静态变量的初始化要优先于子类的静态代码块/静态变量初始化执行。特别地，类构造器<Clinit>()对于类或者接口来说并不是
	必需的，如果一个类中没有静态代码块，也没有对变量的赋值操作，那么编译器可以不为这个类生产类构造器<clinit>()。此外，
	在同一个类加载器下，一个类只会被初始化一次，但是一个类可以任意的实例化对象，也就是说，在一个类的生命周期中，“类构造器
	<clinit>()最多被虚拟机调用一次，而实例构造器<init>()则被虚拟机调用多次，只要程序员还在创建对象”。
		注意，这里所谓的实例构造器<init>()是指收集类中的所有实例变量的赋值动作、实例代码和构造函数合并产生的，类似于
	上文对Foo类的构造函数和Bar类的构造函数做的等价交换。
	
四.总结
	1、一个实例变量在对象初始化过程中会被赋值几次？
		我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值（准备阶段），这个
	复制过程是没有办法避免的，如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。如果
	我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量被第三次赋值了。如果我们在构造函数中，也对变量x做了
	初始化操作，那么这个时候，变量x就被第四次赋值。也就是说，在java对象初始化过程中，一个实例变量最多可以被初始化4次。
	
	2、类的初始化过程和类的实例化过程的异同？
		类的初始化是指类在加载过程中的初始化阶段对类变量按照程序员的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后
	创建对象的过程。
	
	3、假如一个类还没加载到内存中，那么在创建一个该类的实例中，具体过程是怎样的？
		我们知道，要想创建一个类的实例，必须将类加载到内存并进行初始化，也就是说，类初始化操作是类实例化操作之前，但并不意味着：
	只有类初始化操作结束才能进行类实例化操作。例如，笔者在博文《JVM类加载机制概述：加载时机与加载过程》中所提到的案例
	classloader.MyTest6.java
	
		总的来说，类实例化的一般过程：“父类的类构造器<clinit>()->子类的类构造器<clinit>()->父类的成员变量和实例代码块->
	父类的构造函数->子类的成员变量和实例代码块->子类的构造函数”。
		
	