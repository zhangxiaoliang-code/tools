https://segmentfault.com/a/1190000011291179
Java三种代理模式：静态代理、动态代理和cglib代理
一、代理模式介绍
    代理模式是一种设计模式，提供了对目标对象的额外的访问，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下扩展目标对象的功能。
    简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。
    例子：
        我们生活中经常去火车站买火车票，但是人一多的话，就会非常拥挤，于是就有了代售点，我们能从代售点买火车票。这其中就是代理模式的体现，
    代售点代理了火车站的对象，提供了购买车票的方法。

二、静态代理
    这种代理方式需要代理对象和目标对象实现一样的接口。
    优点：可以在不修改目标对象的前提下修改目标对象的功能。
    缺点：1.冗余。由于代理对象要实现和目标对象一致的接口，这样会出现过多的代理类。
         2.不宜维护。一旦接口增加方法，代理对象和目标对象都要修改。
    例子：staticproxy包下

三、动态代理
    动态代理利用JDK API，动态的在内存中构建对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或者接口代理。
    静态代理与动态代理的区别：
        静态代理是在编译时就已经实现，编译完成代理类是一个class类。
        动态代理是在运行时动态生成的，既在编译完成后没有实际的class文件，而是在运行时动态生成字节码，并加载到JVM中。

    特点：动态代理对象不需要实现接口，而目标对象需要实现接口，否则不是实现动态代理。
    JDK中生成代理对象主要涉及的类有：
        java.lang.reflect.Proxy, 主要方法为
        static Object newProxyInstance(ClassLoader loader, //指定当前目标对象使用类加载器
            Class<?>[] interfaces, //目标对象使用的接口类型
            InvcotionHandler h,     //事件处理器
        )
        //返回一个指定接口的代理实例，该接口可以将方法调用指派到指定的调用处理程序。

        java.lang.reflect.InvoctionHandle, 主要方法为
        Object invoke(Object proxy, Method method, Object[] args)
        //在代理实例上处理方法调用并返回结果。
    例子：dynamicproxy包下(保存用户功能的动态代理实现)

四、cglib代理
